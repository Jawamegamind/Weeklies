<!doctype html>
<html lang="en"><head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>Route Protection Analysis</title>
<link rel="stylesheet" href="../assets/custom.css">
</head><body class="pdoc"><main class="pdoc">
<article><h1>Route Protection Analysis &amp; Implementation Guide</h1>
<h2>Current Status: ⚠️ <strong>Inconsistent &amp; Vulnerable</strong></h2>
<hr />
<h2>Executive Summary</h2>
<p><strong>You are CORRECT</strong> — The application has <strong>inconsistent route protection</strong> with <strong>critical security vulnerabilities</strong>:</p>
<ol>
<li>✅ <strong>Manual checks exist</strong> but are <strong>inconsistently applied</strong></li>
<li>❌ <strong>No centralized authentication system</strong> (no Flask-Login or decorators)</li>
<li>❌ <strong>Code duplication</strong> (same check repeated ~10 times)</li>
<li>⚠️ <strong>Logout route is unprotected</strong> (anyone can call it)</li>
<li>❌ <strong>No authorization checks</strong> (users can access other users' data in some cases)</li>
<li>❌ <strong>No CSRF protection</strong> on forms</li>
<li>❌ <strong>Session security issues</strong> (weak secret key)</li>
</ol>
<hr />
<h2>Detailed Analysis</h2>
<h3>Current "Protection" Pattern</h3>
<p>Every protected route manually checks:</p>
<pre><code class="language-python">if session.get('Username') is None:
    return redirect(url_for('login'))
</code></pre>
<p><strong>Example from <code>/profile</code> route:</strong></p>
<pre><code class="language-python">@app.route('/profile')
def profile():
    # Must be logged in
    if session.get('Username') is None:
        return redirect(url_for('login'))
    # ... rest of code
</code></pre>
<h3>Routes with Manual Protection (9 routes)</h3>
<table>
<thead>
<tr>
<th>Route</th>
<th>Line</th>
<th>Check Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/</code> (index)</td>
<td>207</td>
<td><code>session.get("Username") is None</code></td>
</tr>
<tr>
<td><code>/profile</code></td>
<td>390</td>
<td><code>session.get('Username') is None</code></td>
</tr>
<tr>
<td><code>/profile/edit</code></td>
<td>495</td>
<td><code>session.get('Username') is None</code></td>
</tr>
<tr>
<td><code>/profile/change-password</code></td>
<td>562</td>
<td><code>session.get('Username') is None</code></td>
</tr>
<tr>
<td><code>/order</code></td>
<td>629</td>
<td><code>session.get("Username") is None</code></td>
</tr>
<tr>
<td><code>/orders</code></td>
<td>852</td>
<td><code>session.get('Username') is None</code></td>
</tr>
<tr>
<td><code>/restaurants</code></td>
<td>921</td>
<td><code>session.get('Username') is None</code></td>
</tr>
<tr>
<td><code>/orders/&lt;ord_id&gt;/receipt.pdf</code></td>
<td>984</td>
<td><code>session.get('Username') is None</code></td>
</tr>
<tr>
<td><code>/db</code></td>
<td>1024</td>
<td><code>session.get('Username') is None</code></td>
</tr>
</tbody>
</table>
<h3>Routes WITHOUT Protection (3 routes)</h3>
<table>
<thead>
<tr>
<th>Route</th>
<th>Line</th>
<th>Public?</th>
<th>Vulnerability</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/login</code></td>
<td>267</td>
<td>✅ Should be public</td>
<td>None</td>
</tr>
<tr>
<td><code>/register</code></td>
<td>318</td>
<td>✅ Should be public</td>
<td>None</td>
</tr>
<tr>
<td><code>/logout</code></td>
<td>304</td>
<td>❌ <strong>SHOULD BE PROTECTED</strong></td>
<td>⚠️ Anyone can logout any user!</td>
</tr>
</tbody>
</table>
<hr />
<h2>Critical Vulnerabilities</h2>
<h3>1. ❌ Logout Route Unprotected</h3>
<p><strong>Current Code (Line 304):</strong></p>
<pre><code class="language-python">@app.route('/logout')
def logout():
    &quot;&quot;&quot;
    Clear session and redirect to login.
    &quot;&quot;&quot;
    for k in [&quot;Username&quot;,&quot;Fname&quot;,&quot;Lname&quot;,&quot;Email&quot;,&quot;Phone&quot;,&quot;Wallet&quot;,&quot;Preferences&quot;,&quot;Allergies&quot;,&quot;GeneratedMenu&quot;]:
        session.pop(k, None)
    return redirect(url_for(&quot;login&quot;))
</code></pre>
<p><strong>Problem:</strong> Anyone (even unauthenticated attackers) can call <code>/logout</code> and clear another user's session if they know the session ID or can trigger a request.</p>
<p><strong>Attack Vector:</strong></p>
<pre><code class="language-html">&lt;!-- Attacker embeds this on their site --&gt;
&lt;img src=&quot;https://yourapp.com/logout&quot; style=&quot;display:none&quot;&gt;
&lt;!-- When victim visits attacker's site, they get logged out --&gt;
</code></pre>
<p><strong>Fix:</strong> Add authentication check and CSRF protection.</p>
<hr />
<h3>2. ⚠️ Weak Secret Key</h3>
<p><strong>Line 20:</strong></p>
<pre><code class="language-python">app.config['SECRET_KEY'] = 'your_secret_key_here'
</code></pre>
<p><strong>Problem:</strong> This is a <strong>placeholder secret</strong> that should <strong>never</strong> be used in production. Anyone can forge session cookies with this known key.</p>
<p><strong>Fix:</strong> Use environment variable with strong random key:</p>
<pre><code class="language-python">app.config['SECRET_KEY'] = os.environ.get('FLASK_SECRET_KEY') or os.urandom(32).hex()
</code></pre>
<hr />
<h3>3. ⚠️ Authorization Gaps</h3>
<p><strong>Problem:</strong> Some routes check <strong>authentication</strong> (is user logged in?) but not <strong>authorization</strong> (is user allowed to access THIS resource?).</p>
<p><strong>Example:</strong> <code>/orders/&lt;ord_id&gt;/receipt.pdf</code> (Line 984-1000):</p>
<pre><code class="language-python">if session.get('Username') is None:
    return redirect(url_for('login'))

# Load order
conn = create_connection(db_file)
try:
    row = fetch_one(conn, 'SELECT usr_id FROM &quot;Order&quot; WHERE ord_id = ?', (ord_id,))
    if not row:
        abort(404)  # order doesn't exist
    # Check: does this order belong to this user?
    if session.get('usr_id') and row[0] != session['usr_id']:
        abort(403)  # forbidden
</code></pre>
<p>✅ <strong>This route DOES have authorization</strong> — but it's inconsistent. Other routes may not have this check.</p>
<p><strong>Potential Issue:</strong> What if <code>session.get('usr_id')</code> is <code>None</code> but <code>session.get('Username')</code> exists? The authorization check would be bypassed!</p>
<hr />
<h3>4. ❌ No CSRF Protection</h3>
<p><strong>Problem:</strong> Forms don't use CSRF tokens. Attackers can forge requests.</p>
<p><strong>Attack Example:</strong></p>
<pre><code class="language-html">&lt;!-- Attacker's malicious site --&gt;
&lt;form action=&quot;https://yourapp.com/order&quot; method=&quot;POST&quot; id=&quot;evil&quot;&gt;
  &lt;input name=&quot;restaurant_id&quot; value=&quot;1&quot;&gt;
  &lt;input name=&quot;items[][itm_id]&quot; value=&quot;42&quot;&gt;
  &lt;input name=&quot;items[][qty]&quot; value=&quot;100&quot;&gt;
&lt;/form&gt;
&lt;script&gt;document.getElementById('evil').submit();&lt;/script&gt;
&lt;!-- If victim is logged in, this places an order without their consent --&gt;
</code></pre>
<p><strong>Fix:</strong> Use Flask-WTF with CSRF protection.</p>
<hr />
<h3>5. ⚠️ Session Permanence Issues</h3>
<p><strong>Line 297-298:</strong></p>
<pre><code class="language-python">session.permanent = True
app.permanent_session_lifetime = timedelta(minutes=30)
</code></pre>
<p><strong>Problem:</strong> Sessions expire after 30 minutes of <strong>creation</strong>, not <strong>inactivity</strong>. User gets logged out even if actively using the app.</p>
<p><strong>Better Approach:</strong> Reset session timer on each request, or use <code>flask-login</code> which handles this.</p>
<hr />
<h2>Code Quality Issues</h2>
<h3>1. Massive Code Duplication</h3>
<p>The same 2-line check is repeated <strong>9 times</strong>:</p>
<pre><code class="language-python">if session.get('Username') is None:
    return redirect(url_for('login'))
</code></pre>
<p><strong>Problems:</strong>
- Hard to maintain (need to update 9 places to change logic)
- Easy to forget when adding new routes
- No consistency in session key checks (some check <code>'Username'</code>, some check <code>'usr_id'</code>)</p>
<hr />
<h3>2. Inconsistent Session Keys</h3>
<p>Different routes check different session keys:
- Most check: <code>session.get('Username')</code>
- Some check: <code>session.get('usr_id')</code>
- One checks: <code>session.get('Email')</code></p>
<p><strong>Problem:</strong> If session keys are inconsistent, protection is unreliable.</p>
<hr />
<h3>3. No Centralized User Loading</h3>
<p>Every route that needs user data does this:</p>
<pre><code class="language-python">conn = create_connection(db_file)
try:
    user = fetch_one(conn, 'SELECT * FROM &quot;User&quot; WHERE email = ?', (session.get('Email'),))
finally:
    close_connection(conn)
</code></pre>
<p><strong>Problem:</strong> DB query on every request, code duplication, potential for SQL injection if not careful.</p>
<hr />
<h2>Recommended Implementation</h2>
<h3>Option 1: Decorator-Based Protection (Lightweight)</h3>
<p><strong>Best for:</strong> Current architecture with minimal changes.</p>
<h4>Step 1: Create Authentication Decorator</h4>
<p>Add near the top of <code>Flask_app.py</code> (after imports):</p>
<pre><code class="language-python">from functools import wraps

def login_required(f):
    &quot;&quot;&quot;
    Decorator to require authentication for a route.
    Redirects to login if user not authenticated.
    &quot;&quot;&quot;
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if session.get('Username') is None or session.get('usr_id') is None:
            return redirect(url_for('login'))
        return f(*args, **kwargs)
    return decorated_function
</code></pre>
<h4>Step 2: Apply Decorator to Protected Routes</h4>
<p><strong>Before:</strong></p>
<pre><code class="language-python">@app.route('/profile')
def profile():
    if session.get('Username') is None:
        return redirect(url_for('login'))
    # ... rest of code
</code></pre>
<p><strong>After:</strong></p>
<pre><code class="language-python">@app.route('/profile')
@login_required
def profile():
    # ... rest of code (no manual check needed)
</code></pre>
<h4>Step 3: Add Authorization Helper</h4>
<pre><code class="language-python">def require_own_resource(resource_user_id: int):
    &quot;&quot;&quot;
    Check if current user owns a resource.
    Raises 403 Forbidden if not.
    &quot;&quot;&quot;
    current_user_id = session.get('usr_id')
    if not current_user_id or current_user_id != resource_user_id:
        abort(403)
</code></pre>
<p><strong>Usage Example:</strong></p>
<pre><code class="language-python">@app.route('/orders/&lt;int:ord_id&gt;/receipt.pdf')
@login_required
def order_receipt(ord_id: int):
    conn = create_connection(db_file)
    try:
        row = fetch_one(conn, 'SELECT usr_id FROM &quot;Order&quot; WHERE ord_id = ?', (ord_id,))
        if not row:
            abort(404)
        require_own_resource(row[0])  # Authorization check
    finally:
        close_connection(conn)
    # ... rest of code
</code></pre>
<hr />
<h3>Option 2: Flask-Login (Industry Standard)</h3>
<p><strong>Best for:</strong> Professional production-ready authentication.</p>
<h4>Step 1: Install Flask-Login</h4>
<pre><code class="language-bash">pip install flask-login
</code></pre>
<p>Add to <code>requirements.txt</code>:</p>
<pre><code>Flask-Login==0.6.3
</code></pre>
<h4>Step 2: Initialize Flask-Login</h4>
<pre><code class="language-python">from flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user

# Initialize LoginManager
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login'  # Redirect to /login if not authenticated
login_manager.login_message = 'Please log in to access this page.'
</code></pre>
<h4>Step 3: Create User Model</h4>
<pre><code class="language-python">class User(UserMixin):
    def __init__(self, usr_id, email, first_name, last_name, phone, wallet, preferences, allergies, generated_menu):
        self.id = usr_id  # Flask-Login requires 'id' attribute
        self.email = email
        self.first_name = first_name
        self.last_name = last_name
        self.phone = phone
        self.wallet = wallet
        self.preferences = preferences
        self.allergies = allergies
        self.generated_menu = generated_menu

    @property
    def username(self):
        return f&quot;{self.first_name} {self.last_name}&quot;
</code></pre>
<h4>Step 4: User Loader Callback</h4>
<pre><code class="language-python">@login_manager.user_loader
def load_user(user_id):
    &quot;&quot;&quot;
    Flask-Login calls this to reload user from session.
    &quot;&quot;&quot;
    conn = create_connection(db_file)
    try:
        user_data = fetch_one(conn, 'SELECT * FROM &quot;User&quot; WHERE usr_id = ?', (int(user_id),))
        if user_data:
            return User(
                usr_id=user_data[0],
                email=user_data[3],
                first_name=user_data[1],
                last_name=user_data[2],
                phone=user_data[4],
                wallet=user_data[6],
                preferences=user_data[7] if len(user_data) &gt; 7 else &quot;&quot;,
                allergies=user_data[8] if len(user_data) &gt; 8 else &quot;&quot;,
                generated_menu=user_data[9] if len(user_data) &gt; 9 else &quot;&quot;
            )
    finally:
        close_connection(conn)
    return None
</code></pre>
<h4>Step 5: Update Login Route</h4>
<pre><code class="language-python">@app.route('/login', methods=['GET','POST'])
def login():
    if request.method == &quot;POST&quot;:
        email = (request.form.get(&quot;email&quot;) or &quot;&quot;).strip().lower()
        password = request.form.get(&quot;password&quot;) or &quot;&quot;

        conn = create_connection(db_file)
        try:
            user_data = fetch_one(conn, 'SELECT * FROM &quot;User&quot; WHERE email = ?', (email,))
        finally:
            close_connection(conn)

        if user_data and check_password_hash(user_data[5], password):
            user = User(
                usr_id=user_data[0],
                email=user_data[3],
                first_name=user_data[1],
                last_name=user_data[2],
                phone=user_data[4],
                wallet=user_data[6],
                preferences=user_data[7] if len(user_data) &gt; 7 else &quot;&quot;,
                allergies=user_data[8] if len(user_data) &gt; 8 else &quot;&quot;,
                generated_menu=user_data[9] if len(user_data) &gt; 9 else &quot;&quot;
            )
            login_user(user, remember=True)  # Flask-Login handles session
            return redirect(url_for(&quot;index&quot;))

        return render_template(&quot;login.html&quot;, error=&quot;Invalid credentials&quot;)

    return render_template(&quot;login.html&quot;)
</code></pre>
<h4>Step 6: Update Logout Route</h4>
<pre><code class="language-python">@app.route('/logout')
@login_required  # Protect logout route!
def logout():
    logout_user()  # Flask-Login clears session
    return redirect(url_for(&quot;login&quot;))
</code></pre>
<h4>Step 7: Protect Routes with Decorator</h4>
<pre><code class="language-python">@app.route('/profile')
@login_required  # Automatic redirect to /login if not authenticated
def profile():
    # Access current user via 'current_user' object
    email = current_user.email
    wallet = current_user.wallet
    # ... rest of code
</code></pre>
<h4>Step 8: Replace Session Access with current_user</h4>
<p><strong>Before:</strong></p>
<pre><code class="language-python">session.get('Username')
session.get('usr_id')
session.get('Email')
</code></pre>
<p><strong>After:</strong></p>
<pre><code class="language-python">current_user.username  # or current_user.first_name + ' ' + current_user.last_name
current_user.id
current_user.email
</code></pre>
<hr />
<h3>Option 3: Flask-Login + CSRF Protection (Most Secure)</h3>
<p>Add <strong>Flask-WTF</strong> for CSRF tokens on all forms.</p>
<h4>Install</h4>
<pre><code class="language-bash">pip install flask-wtf
</code></pre>
<h4>Configure</h4>
<pre><code class="language-python">from flask_wtf.csrf import CSRFProtect

csrf = CSRFProtect(app)
</code></pre>
<h4>Update Forms</h4>
<pre><code class="language-html">&lt;!-- In login.html, register.html, etc. --&gt;
&lt;form method=&quot;POST&quot;&gt;
  {{ csrf_token() }}  &lt;!-- Add this line --&gt;
  &lt;input name=&quot;email&quot; type=&quot;email&quot; required&gt;
  &lt;input name=&quot;password&quot; type=&quot;password&quot; required&gt;
  &lt;button type=&quot;submit&quot;&gt;Login&lt;/button&gt;
&lt;/form&gt;
</code></pre>
<hr />
<h2>Migration Roadmap</h2>
<h3>Phase 1: Quick Wins (1-2 hours)</h3>
<ol>
<li>
<p><strong>Fix Secret Key</strong>
   <code>python
   app.config['SECRET_KEY'] = os.environ.get('FLASK_SECRET_KEY') or os.urandom(32).hex()</code></p>
</li>
<li>
<p><strong>Protect Logout Route</strong>
   <code>python
   @app.route('/logout')
   def logout():
       if session.get('Username') is None:
           return redirect(url_for('login'))
       # ... rest</code></p>
</li>
<li>
<p><strong>Create <code>login_required</code> Decorator</strong>
   <code>python
   def login_required(f):
       @wraps(f)
       def decorated_function(*args, **kwargs):
           if session.get('Username') is None:
               return redirect(url_for('login'))
           return f(*args, **kwargs)
       return decorated_function</code></p>
</li>
<li>
<p><strong>Apply Decorator to All Protected Routes</strong></p>
</li>
<li>Replace manual checks with <code>@login_required</code></li>
<li>Remove duplicate <code>if session.get('Username') is None:</code> lines</li>
</ol>
<h3>Phase 2: Standardization (2-4 hours)</h3>
<ol>
<li><strong>Consistent Session Keys</strong></li>
<li>Ensure <code>usr_id</code> is always set in login</li>
<li>
<p>Use <code>usr_id</code> consistently for authorization checks</p>
</li>
<li>
<p><strong>Authorization Helper</strong>
   <code>python
   def require_own_resource(resource_user_id):
       if session.get('usr_id') != resource_user_id:
           abort(403)</code></p>
</li>
<li>
<p><strong>Centralize User Loading</strong>
   <code>python
   def get_current_user():
       """Load full user data for current session."""
       email = session.get('Email')
       if not email:
           return None
       conn = create_connection(db_file)
       try:
           return fetch_one(conn, 'SELECT * FROM "User" WHERE email = ?', (email,))
       finally:
           close_connection(conn)</code></p>
</li>
</ol>
<h3>Phase 3: Flask-Login Migration (4-8 hours)</h3>
<ol>
<li>Install <code>flask-login</code></li>
<li>Create <code>User</code> model class</li>
<li>Initialize <code>LoginManager</code></li>
<li>Update login/logout routes</li>
<li>Replace session checks with <code>@login_required</code> + <code>current_user</code></li>
<li>Test all routes</li>
</ol>
<h3>Phase 4: CSRF Protection (2-4 hours)</h3>
<ol>
<li>Install <code>flask-wtf</code></li>
<li>Initialize <code>CSRFProtect</code></li>
<li>Add <code>{{ csrf_token() }}</code> to all forms</li>
<li>Test form submissions</li>
</ol>
<hr />
<h2>Testing Checklist</h2>
<h3>Authentication Tests</h3>
<ul>
<li>[ ] Unauthenticated user redirected to <code>/login</code> for protected routes</li>
<li>[ ] Authenticated user can access protected routes</li>
<li>[ ] Logout clears session and redirects to login</li>
<li>[ ] Login with wrong credentials shows error</li>
<li>[ ] Session expires after timeout</li>
</ul>
<h3>Authorization Tests</h3>
<ul>
<li>[ ] User A cannot access User B's orders</li>
<li>[ ] User A cannot download User B's receipts</li>
<li>[ ] User A cannot edit User B's profile</li>
<li>[ ] Admin routes (if added) only accessible to admins</li>
</ul>
<h3>CSRF Tests</h3>
<ul>
<li>[ ] Form submissions without CSRF token are rejected</li>
<li>[ ] CSRF token changes on each request</li>
<li>[ ] CSRF token matches session</li>
</ul>
<h3>Security Tests</h3>
<ul>
<li>[ ] Secret key is not hardcoded</li>
<li>[ ] Session cookies have <code>HttpOnly</code> and <code>Secure</code> flags</li>
<li>[ ] No SQL injection via session data</li>
<li>[ ] Logout cannot be triggered by GET request from external site</li>
</ul>
<hr />
<h2>Comparison: Current vs. Recommended</h2>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Current</th>
<th>Decorator</th>
<th>Flask-Login</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Authentication</strong></td>
<td>Manual checks (9×)</td>
<td><code>@login_required</code></td>
<td><code>@login_required</code></td>
</tr>
<tr>
<td><strong>Code Duplication</strong></td>
<td>High</td>
<td>Low</td>
<td>None</td>
</tr>
<tr>
<td><strong>Consistency</strong></td>
<td>Poor</td>
<td>Good</td>
<td>Excellent</td>
</tr>
<tr>
<td><strong>Session Management</strong></td>
<td>Manual</td>
<td>Manual</td>
<td>Automatic</td>
</tr>
<tr>
<td><strong>User Loading</strong></td>
<td>Per-route DB query</td>
<td>Per-route DB query</td>
<td>Cached per request</td>
</tr>
<tr>
<td><strong>Authorization</strong></td>
<td>Partial</td>
<td>Helper functions</td>
<td><code>current_user</code> checks</td>
</tr>
<tr>
<td><strong>Logout Protection</strong></td>
<td>❌ None</td>
<td>✅ Protected</td>
<td>✅ Protected</td>
</tr>
<tr>
<td><strong>CSRF Protection</strong></td>
<td>❌ None</td>
<td>❌ None</td>
<td>✅ With Flask-WTF</td>
</tr>
<tr>
<td><strong>Industry Standard</strong></td>
<td>❌ No</td>
<td>⚠️ Custom</td>
<td>✅ Yes</td>
</tr>
<tr>
<td><strong>Effort to Implement</strong></td>
<td>N/A</td>
<td>1-2 hours</td>
<td>4-8 hours</td>
</tr>
<tr>
<td><strong>Maintenance</strong></td>
<td>High</td>
<td>Medium</td>
<td>Low</td>
</tr>
</tbody>
</table>
<hr />
<h2>Recommendation</h2>
<h3>For Your Project (Academic/Final Project)</h3>
<p><strong>Start with Phase 1 (Decorator)</strong> — Quick, demonstrates understanding, minimal disruption.</p>
<p><strong>Then add Flask-Login</strong> — Shows professional knowledge, better for demo/presentation.</p>
<h3>For Production</h3>
<p><strong>Use Flask-Login + Flask-WTF</strong> — Industry standard, secure, maintainable.</p>
<hr />
<h2>Summary</h2>
<h3>Your Observation: ✅ <strong>100% CORRECT</strong></h3>
<p>The application has:
- ❌ No centralized route protection system
- ⚠️ Inconsistent manual checks (9/12 routes protected)
- ❌ Critical vulnerability: Unprotected logout
- ❌ Weak secret key (hardcoded placeholder)
- ❌ No CSRF protection
- ⚠️ Authorization gaps</p>
<h3>Action Items</h3>
<ol>
<li><strong>Immediate</strong> (Security Fix):</li>
<li>Change secret key to environment variable</li>
<li>Protect <code>/logout</code> route</li>
<li>
<p>Add <code>@login_required</code> decorator</p>
</li>
<li>
<p><strong>Short-term</strong> (Code Quality):</p>
</li>
<li>Replace all manual checks with decorator</li>
<li>Standardize session keys</li>
<li>
<p>Add authorization helpers</p>
</li>
<li>
<p><strong>Long-term</strong> (Best Practice):</p>
</li>
<li>Migrate to Flask-Login</li>
<li>Add CSRF protection</li>
<li>Implement proper session management</li>
</ol>
<p>This is a <strong>critical security issue</strong> that should be addressed before any production deployment or final project submission.</p></article>
<p><a href="../proj2.html">← Back to API Reference</a></p>
</main></body></html>